<!doctype html>
<html>

<head>
	<title>The Illustrated TLS Connection</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="format-detection" content="telephone=no">
	<link rel="stylesheet" href="frombootstrap.css">
	<link rel="stylesheet" href="illustrated.css">
	<script src="illustrated.js"></script>
</head>

<body>
<div class="container">
	<h1>The Illustrated TLS Connection</h1>

	<h3>Every byte of a TLS connection explained and reproduced.</h3>

	<div class="outerblock">
	<p>In this demonstration a client has connection to a server,
	negotiated a TLS 1.2 session, sent "ping", received "pong",
	and then terminated the session. Click below to begin
	exploring.</p>
	</div>

<div class="record client">
<div class="label">Client Hello</div>
<div class="explanation">
	We begin the session by having the client say "Hello".
	In this message the client provides the following:
	<ul>
	<li>protocol version
	<li>client random data (used later in the handshake)
	<li>an optional session id to resume
	<li>a list of cipher suites
	<li>a list of compression methods
	<li>a list of extensions
	</ul>
</div>
<span class="record-data">
	<span class="string">
		<span class="label">record header</span>
		<span class="bytes">
			16 03 01 00 a5
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<br/><br/>
			In this record header we see the following:
			<ul>
			<li><tt>16</tt> - type is 0x16 (handshake record)
			<li><tt>03 01</tt> - protocol version is 3.1 (also known as TLS 1.0)
			<li><tt>00 a5</tt> - the length of the record payload is 0xA5 (165) bytes
			</ul>
			Interestingly the version is 3.1 (TLS 1.0) instead
			of the expected 3.3 (TLS 1.2).  Looking through the
			golang crypto/tls library we find the following
			comment:
<pre><code>if vers == 0 {
    // Some TLS servers fail if the record version is
    // greater than TLS 1.0 for the initial ClientHello.
    vers = VersionTLS10
}</code></pre>
			All data following this header is the payload for this record.
		</div>
	</span>

	<span class="string">
		<span class="label">handshake header</span>
		<span class="bytes">
			01 00 00 a1
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<br/><br/>
			In this message we see:
			<ul>
			<li><tt>01</tt> - handshake message type 0x01 (client hello)
			<li><tt>00 00 a1</tt> - payload length of 0xA1 (161) bytes
			</ul>
			All data following this header is the payload for this message.
		</div>
	</span>

	<span class="string">
		<span class="label">client version</span>
		<span class="bytes">
			03 03
		</span>
		<div class="explanation">
			The protocol version of 3.3 (meaning TLS 1.2) is given.
			<br/><br/>
			This choice of version number (3.3 rather
			than 1.2) is due to TLS 1.0 being a minor
			revision of the SSL 3.0 protocol, thus being
			assigned version 3.1.
		</div>
	</span>

	<span class="string">
		<span class="label">client random</span>
		<span class="bytes">
			00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
		</span>
		<div class="explanation">
			The client provides 32 bytes of cryptographically secure random data.
			In this example we've made the random data predictable to make it easier to recognize.
			<br/><br/>
			The TLS 1.2 spec says that the first 4 bytes
			should be the current time in seconds-since-1970
			but this is now recommended against as it enables
			fingerprinting of hosts and servers.
		</div>
	</span>

	<span class="string">
		<span class="label">session id</span>
		<span class="bytes">
			00
		</span>
		<div class="explanation">
			The client can provide the ID of a previous
			TLS session against this server which it
			is able to resume.  For this to work both
			the server and client will have remembered
			key information from the previous connection
			in memory.  Resuming a connection saves a
			lot of computation and network round-trip
			time so it is performed whenever possible.
			<ul>
			<li><tt>00</tt> - length of zero (no session id is provided)
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">cipher suites</span>
		<span class="bytes">
			00 20 cc a8
			cc a9 c0 2f c0 30 c0 2b c0 2c c0 13 c0 09 c0 14
			c0 0a 00 9c 00 9d 00 2f 00 35 c0 12 00 0a
		</span>
		<div class="explanation">
			The client provides an ordered list of which
			cryptographic methods it will support for
			key exchange, encryption with that exchanged
			key, and message authentication method.
			The list is in the order preferred by the
			client, with highest preference first.
			<ul>
			<li><tt>00 20</tt> - 0x20 (32) bytes of cipher suite data
			<li><tt>cc a8</tt> - assigned value for <tt>ECDHE-RSA-CHACHA20-POLY1305-SHA256</tt>
			<li><tt>cc a9</tt> - assigned value for <tt>ECDHE-ECDSA-CHACHA20-POLY1305-SHA256</tt>
			<li><tt>c0 2f</tt> - assigned value for <tt>ECDHE-RSA-AES128-GCM-SHA256</tt>
			<li><tt>c0 30</tt> - assigned value for <tt>ECDHE-RSA-AES256-GCM-SHA384</tt>
			<li><tt>c0 2b</tt> - assigned value for <tt>ECDHE-ECDSA-AES128-GCM-SHA256</tt>
			<li><tt>c0 2c</tt> - assigned value for <tt>ECDHE-ECDSA-AES256-GCM-SHA384</tt>
			<li><tt>c0 13</tt> - assigned value for <tt>ECDHE-RSA-AES128-SHA</tt>
			<li><tt>c0 09</tt> - assigned value for <tt>ECDHE-ECDSA-AES128-SHA</tt>
			<li><tt>c0 14</tt> - assigned value for <tt>ECDHE-RSA-AES256-SHA</tt>
			<li><tt>c0 0a</tt> - assigned value for <tt>ECDHE-ECDSA-AES256-SHA</tt>
			<li><tt>00 9c</tt> - assigned value for <tt>RSA-AES128-GCM-SHA256</tt>
			<li><tt>00 9d</tt> - assigned value for <tt>RSA-AES256-GCM-SHA384</tt>
			<li><tt>00 2f</tt> - assigned value for <tt>RSA-AES128-SHA</tt>
			<li><tt>00 35</tt> - assigned value for <tt>RSA-AES256-SHA</tt>
			<li><tt>c0 12</tt> - assigned value for <tt>ECDHE-RSA-3DES-EDE-SHA</tt>
			<li><tt>00 0a</tt> - assigned value for <tt>RSA-3DES-EDE-SHA</tt>
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">compression methods</span>
		<span class="bytes">
			01 00
		</span>
		<div class="explanation">
			The client provides an ordered list of which
			compression methods it will support.  This
			compression would be applied before encryption
			(as properly encrypted data is usually incompressible).
			<ul>
			<li><tt>01</tt> - 0x1 (1) bytes of compression methods
			<li><tt>00</tt> - assigned value for no compression
			</ul>
			Compression has characteristics that can weaken
			the security of the encrypted data so this feature
			has been removed from future TLS protocols.
			<br/>&nbsp;
		</div>
	</span>

	<span class="string">
		<span class="label">ext length</span>
		<span class="bytes">
			00 58
		</span>
		<div class="explanation">
			The client has provided a list of optional
			extensions which the server can use to
			take action or enable new features.
			<br/><br/>
			Each extension will start with two bytes
			that indicate which extension it is, followed
			by a two-byte content length field, followed
			by the contents of the extension.
			<ul>
			<li><tt>00 58</tt> - the extensions will take 0x58 (88) bytes of data
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">ext - server name</span>
		<span class="bytes">
			00 00 00 18 00 16 00 00 13 65 78 61 6d 70 6c 65 2e 75 6c 66 68 65 69 6d 2e 6e 65 74
		</span>
		<div class="explanation">
			The client has provided the name of the
			server it is contacting, also known as SNI
			(Server Name Indication).
			<br/><br/>
			Without this extension a HTTPS server would
			not be able to provide service for multiple
			hostnames on a single IP address (virtual
			hosts) because it couldn't know which
			hostname's certificate to send until
			after the TLS session was negotiated and the
			HTTP request was made.
			<ul>
				<li><tt>00 00</tt> - extension "server name"
				<li><tt>00 18</tt> - 0x18 (24) bytes of extension data follows
				<li><tt>00 16</tt> - 0x16 (22) bytes of first (and only) list entry follows
				<li><tt>00</tt> - list entry is type 0x00 "DNS hostname"
				<li><tt>00 13</tt> - 0x13 (19) bytes of hostname follows
				<li><tt>65 78 61 ... 6e 65 74</tt> - "example.ulfheim.net"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">ext - status request</span>
		<span class="bytes">
			00 05 00 05 01 00 00 00 00
		</span>
		<div class="explanation">
			The client provides permission for the
			server to provide OCSP information in its response.
			OCSP can be used to check whether a certificate
			has been revoked.
			<br/><br/>
			This form of the client sending an empty
			extension is necessary because
			it is a fatal error for the server
			to reply with an extension that the client
			did not provide first.  Therefore the client
			sends an empty form of the extension, and
			the server replies with the extension
			populated with data.
			<ul>
				<li><tt>00 05</tt> - extension "status request"
				<li><tt>00 05</tt> - 0x5 (5) bytes of extension data follows
				<li><tt>00 00</tt> - 0x0 (0) bytes of responderID information
				<li><tt>00 00</tt> - 0x0 (0) bytes of request extension information
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">ext - supported groups</span>
		<span class="bytes">
			00 0a 00 0a 00 08 00 1d 00 17 00 18 00 19
		</span>
		<div class="explanation">
			The client has indicated that it supports
			elliptic curve (EC) cryptography for 4 curves.
			To make this extension more generic for
			other cryptography types it now calls these
			"supported groups" instead of "supported
			curves".
			<ul>
				<li><tt>00 0a</tt> - extension "supported groups"
				<li><tt>00 0a</tt> - 0xA (10) bytes of extension data follows
				<li><tt>00 08</tt> - 0x8 (8) bytes of data are in the curves list
				<li><tt>00 1d</tt> - assigned value for the curve "x25519"
				<li><tt>00 17</tt> - assigned value for the curve "secp256r1"
				<li><tt>00 18</tt> - assigned value for the curve "secp384r1"
				<li><tt>00 19</tt> - assigned value for the curve "secp521r1"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">ext - EC point formats</span>
		<span class="bytes">
			00 0b 00 02 01 00
		</span>
		<div class="explanation">
			During elliptic curve (EC) cryptography the
			client and server will exchange information
			on the points selected, in either compressed
			or uncompressed form.  This extension
			indicates that the client can only parse
			uncompressed information from the server.
			<br/><br/>
			In the next version of TLS the ability to
			negotiate points does not exist (instead a
			single point is pre-selected for each curve),
			so this extension would not be sent.
			<ul>
				<li><tt>00 0b</tt> - extension "EC points format"
				<li><tt>00 02</tt> - 0x2 (2) bytes of extension data follows
				<li><tt>00 01</tt> - 0x1 (1) bytes of data are in the supported formats list
				<li><tt>00</tt> - assigned value for uncompressed form
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">ext - signature algorithms</span>
		<span class="bytes">
			00 0d 00 12 00 10 04 01 04 03 05 01 05 03 06 01 06 03 02 01 02 03
		</span>
		<div class="explanation">
			As TLS has developed it has become necessary to
			support stronger signature algorithms such
			as SHA-256 while still supporting earlier
			implementations that used MD5 and SHA1.
			This extension indicates which signature
			algorithms the client is capable
			of using.
			<ul>
				<li><tt>00 0d</tt> - extension "Signature Algorithms"
				<li><tt>00 12</tt> - 0x12 (18) bytes of extension data follows
				<li><tt>00 10</tt> - 0x10 (16) bytes of data are in the following list of algorithms
				<li><tt>04 01</tt> - assigned value for RSA/PKCS1/SHA256
				<li><tt>04 03</tt> - assigned value for ECDSA/SECP256r1/SHA256
				<li><tt>05 01</tt> - assigned value for RSA/PKCS1/SHA386
				<li><tt>05 03</tt> - assigned value for ECDSA/SECP384r1/SHA384
				<li><tt>06 01</tt> - assigned value for RSA/PKCS1/SHA512
				<li><tt>06 03</tt> - assigned value for ECDSA/SECP521r1/SHA512
				<li><tt>02 01</tt> - assigned value for RSA/PKCS1/SHA1
				<li><tt>02 03</tt> - assigned value for ECDSA/SHA1
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">ext - renegotiation info</span>
		<span class="bytes">
			ff 01 00 01 00
		</span>
		<div class="explanation">
			The presence of this extension prevents a type of attack performed with TLS renegotation.
			<br/><br/>
			The ability to renegotiate a connection has been removed from the next version of this
			protocol (TLS 1.3) so this will no longer be necessary.
			<ul>
				<li><tt>ff 01</tt> - extension "Renegotiation Info"
				<li><tt>00 01</tt> - 0x1 (1) bytes of extension data follows
				<li><tt>00</tt> - length of renegotation data is zero, because this is a new connection
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">ext - SCT</span>
		<span class="bytes">
			00 12 00 00
		</span>
		<div class="explanation">
			The client provides permission for the
			server to return a signed certificate
			timestamp.
			<br/><br/>
			This form of the client sending an empty
			extension is necessary because
			it is a fatal error for the server
			to reply with an extension that the client
			did not provide first.  Therefore the client
			sends an empty form of the extension, and
			the server replies with the extension
			populated with data.
			<ul>
				<li><tt>00 12</tt> - extension "signed certificate timestamp"
				<li><tt>00 00</tt> - 0x0 (0) bytes of extension data follows
			</ul>
		</div>
	</span>
</span>
</span>
</div>

<div class="record server">
<div class="label">Server Hello</div>
<div class="explanation">
	The server says "hello" back.  In this message the server provides the following:
	<ul>
	<li>protocol version
	<li>server random data (used later in the handshake)
	<li>a session id
	<li>a selected cipher suite
	<li>a selected compression method
	<li>a list of extensions
	</ul>
</div>
<span class="record-data">
	<span class="string">
		<span class="label">record header</span>
		<span class="bytes">
			16 03 03 00 31
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<br/><br/>
			In this record header we see the following:
			<ul>
			<li><tt>16</tt> - type is 0x16 (handshake record)
			<li><tt>03 03</tt> - protocol version is 3.3 (TLS 1.2)
			<li><tt>00 31</tt> - the length of the record payload is 0x31 (49) bytes
			</ul>
			All data following this header is the payload for this record.
		</div>
	</span>

	<span class="string">
		<span class="label">handshake header</span>
		<span class="bytes">
			02 00 00 2d
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<br/><br/>
			In this message we see:
			<ul>
			<li><tt>02</tt> - handshake message type 0x02 (server hello)
			<li><tt>00 00 2d</tt> - payload length of 0x2D (45) bytes
			</ul>
			All data following this header is the payload for this message.
		</div>
	</span>

	<span class="string">
		<span class="label">server version</span>
		<span class="bytes">
			03 03
		</span>
		<div class="explanation">
			The protocol version of 3.3 (TLS 1.2) is given.
			<br/><br/>
			The reason for this version number (3.3
			rather than 1.2) is that TLS 1.0 was a minor
			revision of the SSL 3.0 protocol created
			by Netscape, therefore it was assigned
			version 3.1.
		</div>
	</span>

	<span class="string">
		<span class="label">server random</span>
		<span class="bytes">
			70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f
			80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f
		</span>
		<div class="explanation">
			The server provides 32 bytes of cryptographically secure random data.
			In this example we've made the random data predictable to make it easier to recognize.
			<br/><br/>
			The TLS 1.2 spec says that the first 4 bytes
			should be the current time in seconds-since-1970
			but this is now recommended against as it enables
			fingerprinting of hosts and servers.
		</div>
	</span>

	<span class="string">
		<span class="label">session id</span>
		<span class="bytes">
			00
		</span>
		<div class="explanation">
			The server can provide an ID for this session
			which a client can provide on a later session
			negotiation in an attempt to re-use the key
			data and skip most of the TLS negotiation
			process.  For this to work both the server
			and client will store key information from
			the previous connection in memory.  Resuming
			a connection saves a lot of computation and
			network round-trip time so it is performed
			whenever possible.
			<ul>
			<li><tt>00</tt> - length of zero (no session id is provided)
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">cipher suite</span>
		<span class="bytes">
			cc a8
		</span>
		<div class="explanation">
			The server has selected cipher suite 0xCCA8
			(ECDHE-RSA-CHACHA20-POLY1305-SHA256) from the
			list of options given by the client.
		</div>
	</span>

	<span class="string">
		<span class="label">compression method</span>
		<span class="bytes">
			00
		</span>
		<div class="explanation">
			The server has selected compression method
			0x00 ("Null" compression, or no compression)
			from the list of options given by the client.
		</div>
	</span>

	<span class="string">
		<span class="label">ext length</span>
		<span class="bytes">
			00 05
		</span>
		<div class="explanation">
			The server has returned a list of optional extensions to the client.  Because the server is forbidden from replying with an extension that the client did not send in its hello message, the server knows that the client will support all extensions listed.
			<br/><br/>
			In this case, the extensions data takes
			0x5 (5) bytes.  Each extension will be
			presented in its own following section.
		</div>
	</span>

	<span class="string">
		<span class="label">ext - renegotiation info</span>
		<span class="bytes">
			ff 01 00 01 00
		</span>
		<div class="explanation">
			The presence of this extension prevents a type of attack performed with TLS renegotation.
			<br/><br/>
			The ability to renegotiate a connection has been removed from the next version of this
			protocol (TLS 1.3) so this will no longer be necessary.
			<ul>
				<li><tt>ff 01</tt> - extension "Renegotiation Info"
				<li><tt>00 01</tt> - 0x1 (1) bytes of extension data follows
				<li><tt>00</tt> - length of renegotation data is zero, because this is a new connection
			</ul>
		</div>
	</span>
</span>
</div>

<div class="record server">
<div class="label">Server Certificate</div>
<div class="explanation">
	The server provides a certificate containing items including the following:
	<ul>
	<li>the hostname of the server
	<li>the public key used by this server
	<li>proof from a trusted third party that the owner of this hostname holds the private key for this public key
	</ul>
</div>
<span class="record-data">
	<span class="string">
		<span class="label">record header</span>
		<span class="bytes">
			16 03 03 03 2f
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<br/><br/>
			In this record header we see the following:
			<ul>
			<li><tt>16</tt> - type is 0x16 (handshake record)
			<li><tt>03 03</tt> - protocol version is 3.3 (TLS 1.2)
			<li><tt>03 2f</tt> - the length of the record payload is 0x032f (815) bytes
			</ul>
			All data following this header is the payload for this record.
		</div>
	</span>

	<span class="string">
		<span class="label">handshake header</span>
		<span class="bytes">
			0b 00 03 2b
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<br/><br/>
			In this message we see:
			<ul>
			<li><tt>0b</tt> - handshake message type 0x0B (certificate)
			<li><tt>00 03 2b</tt> - payload length of 0x32B (811) bytes
			</ul>
			All data following this header is the payload for this message.
		</div>
	</span>

	<span class="string">
		<span class="label">certificates length</span>
		<span class="bytes">
			00 03 28
		</span>
		<div class="explanation">
			The certificate message begins with the
			length of all certificate data that will follow.
			<ul>
			<li><tt>00 03 28</tt> - 0x328 (808) bytes of certificates follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">certificate length</span>
		<span class="bytes">
			00 03 25
		</span>
		<div class="explanation">
			The length of the first (and only) certificate.
			<ul>
			<li><tt>00 03 25</tt> - 0x325 (805) bytes of certificate follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">certificate</span>
		<span class="bytes">
			30 82 03 21 30 82 02 09 a0 03 02
			01 02 02 08 15 5a 92 ad c2 04 8f 90 30 0d 06 09
			2a 86 48 86 f7 0d 01 01 0b 05 00 30 22 31 0b 30
			09 06 03 55 04 06 13 02 55 53 31 13 30 11 06 03
			55 04 0a 13 0a 45 78 61 6d 70 6c 65 20 43 41 30
			1e 17 0d 31 38 31 30 30 35 30 31 33 38 31 37 5a
			17 0d 31 39 31 30 30 35 30 31 33 38 31 37 5a 30
			2b 31 0b 30 09 06 03 55 04 06 13 02 55 53 31 1c
			30 1a 06 03 55 04 03 13 13 65 78 61 6d 70 6c 65
			2e 75 6c 66 68 65 69 6d 2e 6e 65 74 30 82 01 22
			30 0d 06 09 2a 86 48 86 f7 0d 01 01 01 05 00 03
			82 01 0f 00 30 82 01 0a 02 82 01 01 00 c4 80 36
			06 ba e7 47 6b 08 94 04 ec a7 b6 91 04 3f f7 92
			bc 19 ee fb 7d 74 d7 a8 0d 00 1e 7b 4b 3a 4a e6
			0f e8 c0 71 fc 73 e7 02 4c 0d bc f4 bd d1 1d 39
			6b ba 70 46 4a 13 e9 4a f8 3d f3 e1 09 59 54 7b
			c9 55 fb 41 2d a3 76 52 11 e1 f3 dc 77 6c aa 53
			37 6e ca 3a ec be c3 aa b7 3b 31 d5 6c b6 52 9c
			80 98 bc c9 e0 28 18 e2 0b f7 f8 a0 3a fd 17 04
			50 9e ce 79 bd 9f 39 f1 ea 69 ec 47 97 2e 83 0f
			b5 ca 95 de 95 a1 e6 04 22 d5 ee be 52 79 54 a1
			e7 bf 8a 86 f6 46 6d 0d 9f 16 95 1a 4c f7 a0 46
			92 59 5c 13 52 f2 54 9e 5a fb 4e bf d7 7a 37 95
			01 44 e4 c0 26 87 4c 65 3e 40 7d 7d 23 07 44 01
			f4 84 ff d0 8f 7a 1f a0 52 10 d1 f4 f0 d5 ce 79
			70 29 32 e2 ca be 70 1f df ad 6b 4b b7 11 01 f4
			4b ad 66 6a 11 13 0f e2 ee 82 9e 4d 02 9d c9 1c
			dd 67 16 db b9 06 18 86 ed c1 ba 94 21 02 03 01
			00 01 a3 52 30 50 30 0e 06 03 55 1d 0f 01 01 ff
			04 04 03 02 05 a0 30 1d 06 03 55 1d 25 04 16 30
			14 06 08 2b 06 01 05 05 07 03 02 06 08 2b 06 01
			05 05 07 03 01 30 1f 06 03 55 1d 23 04 18 30 16
			80 14 89 4f de 5b cc 69 e2 52 cf 3e a3 00 df b1
			97 b8 1d e1 c1 46 30 0d 06 09 2a 86 48 86 f7 0d
			01 01 0b 05 00 03 82 01 01 00 59 16 45 a6 9a 2e
			37 79 e4 f6 dd 27 1a ba 1c 0b fd 6c d7 55 99 b5
			e7 c3 6e 53 3e ff 36 59 08 43 24 c9 e7 a5 04 07
			9d 39 e0 d4 29 87 ff e3 eb dd 09 c1 cf 1d 91 44
			55 87 0b 57 1d d1 9b df 1d 24 f8 bb 9a 11 fe 80
			fd 59 2b a0 39 8c de 11 e2 65 1e 61 8c e5 98 fa
			96 e5 37 2e ef 3d 24 8a fd e1 74 63 eb bf ab b8
			e4 d1 ab 50 2a 54 ec 00 64 e9 2f 78 19 66 0d 3f
			27 cf 20 9e 66 7f ce 5a e2 e4 ac 99 c7 c9 38 18
			f8 b2 51 07 22 df ed 97 f3 2e 3e 93 49 d4 c6 6c
			9e a6 39 6d 74 44 62 a0 6b 42 c6 d5 ba 68 8e ac
			3a 01 7b dd fc 8e 2c fc ad 27 cb 69 d3 cc dc a2
			80 41 44 65 d3 ae 34 8c e0 f3 4a b2 fb 9c 61 83
			71 31 2b 19 10 41 64 1c 23 7f 11 a5 d6 5c 84 4f
			04 04 84 99 38 71 2b 95 9e d6 85 bc 5c 5d d6 45
			ed 19 90 94 73 40 29 26 dc b4 0e 34 69 a1 59 41
			e8 e2 cc a8 4b b6 08 46 36 a0
		</span>
		<div class="explanation">
			The certificate is in ASN.1 DER
			encoding.  The details of this format and
			the content of this binary payload are
			documented <a href="xxx">on another page</a>.
			<a href="files/server.crt" download="server.crt">The certificate</a>
			can be converted to the binary data in this message
			at the command line:
<codesample>
<pre><code>$ openssl x509 -outform der < server.crt | hexdump | head

0000000 30 82 03 21 30 82 02 09 a0 03 02 01 02 02 08 15
0000010 5a 92 ad c2 04 8f 90 30 0d 06 09 2a 86 48 86 f7
... snip ...
</code></pre>
</codesample>
		</div>
	</span>
</span>
</div>

<div class="calculation server">
<div class="label">Server Key Exchange Generation</div>
<div class="explanation">
	The server must calculate a private/public keypair for key
	exchange.  The server has chosen to use an elliptical curve
	method of key exchange, using the x25519 curve.
	<br/><br/>
	The private key is chosen by selecting an integer between
	1 and 2<sup>256</sup>-1.  It does this by generating 32 bytes of
	random data.  The
	<a href="files/server-ephemeral-private.key" download="server-ephemeral-private.key">private key</a>
	selected is:

<pre class="ind2"><tt>90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f
a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af</tt></pre>

	The <a href="files/server-ephemeral-public.key" download="server-ephemeral-public.key">public key</a>
	is chosen by multiplying the point x=9 on the x25519 curve
	by the private key.  The public key calculated is:

<pre class="ind2"><tt>9f d7 ad 6d cf f4 29 8d d3 f9 6d 5b 1b 2a f9 10
a0 53 5b 14 88 d7 f8 fa bb 34 9a 98 28 80 b6 15</tt></pre>

	The public key calculation can be confirmed with command line tools:
<codesample>
<pre><code>### requires openssl 1.1.0 or higher
$ openssl pkey -noout -text < server-ephemeral-private.key

X25519 Private-Key:
priv:
    90:91:92:93:94:95:96:97:98:99:9a:9b:9c:9d:9e:
    9f:a0:a1:a2:a3:a4:a5:a6:a7:a8:a9:aa:ab:ac:ad:
    ae:af
pub:
    9f:d7:ad:6d:cf:f4:29:8d:d3:f9:6d:5b:1b:2a:f9:
    10:a0:53:5b:14:88:d7:f8:fa:bb:34:9a:98:28:80:
    b6:15
</code></pre>
</codesample>
</div>
</div>

<div class="record server">
<div class="label">Server Key Exchange</div>
<div class="explanation">
	The server provides information for key exchange.  As part of the
	key exchange process both the server and the client will have a
	keypair of public and private keys, and will send the other party
	their public key.  The shared encryption key will then be generated
	using a combination of each party's private key and the other party's
	public key.
	<br/><br/>
	The parties had agreed on a cipher suite using ECDHE, meaning the
	keypairs will be based on a selected <b>E</b>lliptic <b>C</b>urve,
	<b>D</b>iffie-<b>H</b>ellman will be used, and the keypairs will
	be <b>E</b>phemeral rather than using the public/private key from
	the certificate.
	<br/>&nbsp;
</div>
<span class="record-data">
	<span class="string">
		<span class="label">record header</span>
 		16 03 03 01 2c
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<br/><br/>
			In this record header we see the following:
			<ul>
			<li><tt>16</tt> - type is 0x16 (handshake record)
			<li><tt>03 03</tt> - protocol version is 3.3 (TLS 1.2)
			<li><tt>01 2c</tt> - the length of the record payload is 0x12c (300) bytes
			</ul>
			All data following this header is the payload for this record.
		</div>
	</span>

	<span class="string">
		<span class="label">handshake header</span>
		<span class="bytes">
			0c 00 01 28
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<br/><br/>
			In this message we see:
			<ul>
			<li><tt>0c</tt> - handshake message type 0x0c (server key exchange)
			<li><tt>00 01 28</tt> - payload length of 0x128 (296) bytes
			</ul>
			All data following this header is the payload for this message.
		</div>
	</span>

	<span class="string">
		<span class="label">curve info</span>
		<span class="bytes">
			03 00 1d
		</span>
		<div class="explanation">
			The server chooses the elliptic curve that points will be calculated from.
			<ul>
			<li><tt>03</tt> - assigned value for "named_curve": the following bytes will identify a specific curve
			<li><tt>00 1d</tt> - curve 0x001d ("curve x25519")
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">public key</span>
		<span class="bytes">
			20 9f d7 ad 6d cf f4 29 8d d3 f9 6d 5b 1b 2a f9
			10 a0 53 5b 14 88 d7 f8 fa bb 34 9a 98 28 80 b6
			15
		</span>
		<div class="explanation">
			The server provides its public key.
			<ul>
			<li><tt>20</tt> - length of 0x20 (32) bytes
			<li><tt>9f d7 ... b6 15</tt> - public key
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">signature</span>
		<span class="bytes">
			04 01 01 00 04 02 b6 61 f7
			c1 91 ee 59 be 45 37 66 39 bd c3 d4 bb 81 e1 15
			ca 73 c8 34 8b 52 5b 0d 23 38 aa 14 46 67 ed 94
			31 02 14 12 cd 9b 84 4c ba 29 93 4a aa cc e8 73
			41 4e c1 1c b0 2e 27 2d 0a d8 1f 76 7d 33 07 67
			21 f1 3b f3 60 20 cf 0b 1f d0 ec b0 78 de 11 28
			be ba 09 49 eb ec e1 a1 f9 6e 20 9d c3 6e 4f ff
			d3 6b 67 3a 7d dc 15 97 ad 44 08 e4 85 c4 ad b2
			c8 73 84 12 49 37 25 23 80 9e 43 12 d0 c7 b3 52
			2e f9 83 ca c1 e0 39 35 ff 13 a8 e9 6b a6 81 a6
			2e 40 d3 e7 0a 7f f3 58 66 d3 d9 99 3f 9e 26 a6
			34 c8 1b 4e 71 38 0f cd d6 f4 e8 35 f7 5a 64 09
			c7 dc 2c 07 41 0e 6f 87 85 8c 7b 94 c0 1c 2e 32
			f2 91 76 9e ac ca 71 64 3b 8b 98 a9 63 df 0a 32
			9b ea 4e d6 39 7e 8c d0 1a 11 0a b3 61 ac 5b ad
			1c cd 84 0a 6c 8a 6e aa 00 1a 9d 7d 87 dc 33 18
			64 35 71 22 6c 4d d2 c2 ac 41 fb
		</span>
		<div class="explanation">
			Because the server is generating ephemeral keys
			it is not using the public key provided in
			the server certificate.  To prove that the
			server owns the server certificate (giving the certificate
			validity in this TLS session), it signs the
			ephemeral public key with the certificate's
			private key.  This signature can be
			validated with the certificate's public
			key.
			<ul>
			<li><tt>04 01</tt> - reserved value for RSA signature with SHA256 hash
			<li><tt>01 00</tt> - length of signature (0x100 or 256 bytes)
			<li><tt>04 02 b6 ... ac 41 fb</tt> - the
			        computed signature for <tt>SHA256(client_hello_random
			        + server_hello_random + curve_info + public_key)</tt>
			</ul>
			We can compute the signature ourselves using
			the <a href="files/server.key" download="server.key">server's private key</a>,
			at the command line:
<codesample>
<pre><code>### client random from Client Hello
$ echo -en '\x00\x01\x02\x03\x04\x05\x06\x07'  > /tmp/compute
$ echo -en '\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f' >> /tmp/compute
$ echo -en '\x10\x11\x12\x13\x14\x15\x16\x17' >> /tmp/compute
$ echo -en '\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f' >> /tmp/compute
### server random from Server Hello
$ echo -en '\x70\x71\x72\x73\x74\x75\x76\x77' >> /tmp/compute
$ echo -en '\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f' >> /tmp/compute
$ echo -en '\x80\x81\x82\x83\x84\x85\x86\x87' >> /tmp/compute
$ echo -en '\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f' >> /tmp/compute
### the curve info section from this message
$ echo -en '\x03\x00\x1d' >> /tmp/compute
### the public key sections from this msg
$ echo -en '\x20\x9f\xd7\xad\x6d\xcf\xf4\x29' >> /tmp/compute
$ echo -en '\x8d\xd3\xf9\x6d\x5b\x1b\x2a\xf9' >> /tmp/compute
$ echo -en '\x10\xa0\x53\x5b\x14\x88\xd7\xf8' >> /tmp/compute
$ echo -en '\xfa\xbb\x34\x9a\x98\x28\x80\xb6\x15' >> /tmp/compute
$ openssl dgst -sign server.key -sha256 /tmp/compute | hexdump

0000000 04 02 b6 61 f7 c1 91 ee 59 be 45 37 66 39 bd c3
... snip ...
00000f0 7d 87 dc 33 18 64 35 71 22 6c 4d d2 c2 ac 41 fb
</code></pre>
</codesample>
		</div>
	</span>
</span>
</div>

<div class="record server">
<div class="label">Server Hello Done</div>
<div class="explanation">
	The server indicates it's finished with its half of the handshake.
	<br/>&nbsp;
</div>
<span class="record-data">
	<span class="string">
		<span class="label">record header</span>
		<span class="bytes">
			16 03 03 00 04
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<br/><br/>
			In this record header we see the following:
			<ul>
			<li><tt>16</tt> - type is 0x16 (handshake record)
			<li><tt>03 03</tt> - protocol version is 3.3 (TLS 1.2)
			<li><tt>00 04</tt> - the length of the record payload is 0x4 (4) bytes
			</ul>
			All data following this header is the payload for this record.
		</div>
	</span>

	<span class="string">
		<span class="label">handshake header</span>
		<span class="bytes">
			0e 00 00 00
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<br/><br/>
			In this message we see:
			<ul>
			<li><tt>0e</tt> - handshake message type 0x0e (server hello done)
			<li><tt>00 00 00</tt> - payload length of 0 bytes (no payload)
			</ul>
		</div>
	</span>
</span>
</div>

<div class="calculation client">
<div class="label">Client Key Exchange Generation</div>
<div class="explanation">
	The client must calculate a private/public keypair for key
	exchange.  It will do this for the elliptical curve
	method of key exchange, using the x25519 curve.
	<br/><br/>
	The private key is chosen by selecting an integer between
	1 and 2<sup>256</sup>-1.  It does this by generating 32 bytes of
	random data.  The
	<a href="files/client-ephemeral-private.key" download="client-ephemeral-private.key">private key</a>
	selected is:

<pre class="ind2"><tt>20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f</tt></pre>

	The <a href="files/client-ephemeral-public.key" download="client-ephemeral-public.key">public key</a>
	is chosen by multiplying the point x=9 on the x25519 curve
	by the private key.  The public key calculated is:

<pre class="ind2"><tt>35 80 72 d6 36 58 80 d1 ae ea 32 9a df 91 21 38
38 51 ed 21 a2 8e 3b 75 e9 65 d0 d2 cd 16 62 54</tt></pre>

	The public key calculation can be confirmed at the command line:
<codesample>
<pre><code>### requires openssl 1.1.0 or higher
$ openssl pkey -noout -text < client-ephemeral-private.key

X25519 Private-Key:
priv:
    20:21:22:23:24:25:26:27:28:29:2a:2b:2c:2d:2e:
    2f:30:31:32:33:34:35:36:37:38:39:3a:3b:3c:3d:
    3e:3f
pub:
    35:80:72:d6:36:58:80:d1:ae:ea:32:9a:df:91:21:
    38:38:51:ed:21:a2:8e:3b:75:e9:65:d0:d2:cd:16:
    62:54
</code></pre>
</codesample>
</div>
</div>
<div class="record client">
<div class="label">Client Key Exchange</div>
<div class="explanation">
	The client provides information for key exchange.  As part of the
	key exchange process both the server and the client will generate a
	keypair of public and private keys, and will send the other party
	their public key.  The shared encryption key will then be generated
	using a function of each party's private key and the other party's
	public key.
	<br/><br/>
	The parties had agreed on a cipher suite using ECDHE, meaning the
	keypairs will be based on a selected <b>E</b>lliptic <b>C</b>urve,
	<b>D</b>iffie-<b>H</b>ellman will be used, and the keypairs will
	be <b>E</b>phemeral rather than using a public/private key from
	the server certificate.
	<br/>&nbsp;
</div>
<span class="record-data">
	<span class="string">
		<span class="label">record header</span>
		<span class="bytes">
			16 03 03 00 25
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<br/><br/>
			In this record header we see the following:
			<ul>
			<li><tt>16</tt> - type is 0x16 (handshake record)
			<li><tt>03 03</tt> - protocol version is 3.3 (TLS 1.2)
			<li><tt>00 25</tt> - the length of the record payload is 0x25 (37) bytes
			</ul>
			All data following this header is the payload for this record.
		</div>
	</span>

	<span class="string">
		<span class="label">handshake header</span>
		<span class="bytes">
			10 00 00 21
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<br/><br/>
			In this message we see:
			<ul>
			<li><tt>10</tt> - handshake message type 0x10 (client key exchange)
			<li><tt>00 00 21</tt> - payload length of 0x21 (33) bytes
			</ul>
			All data following this header is the payload for this message.
		</div>
	</span>

	<span class="string">
		<span class="label">public key</span>
		<span class="bytes">
			20 35 80 72 d6 36 58 80 d1 ae ea 32 9a
			df 91 21 38 38 51 ed 21 a2 8e 3b 75 e9 65 d0 d2 cd 16 62 54
		</span>
		<div class="explanation">
			The client provides its public key.
			<ul>
			<li><tt>20</tt> - length of 0x20 (32) bytes
			<li><tt>35 80 ... 62 54</tt> - public key
			</ul>
		</div>
	</span>
</span>
</div>

<div class="calculation client">
<div class="label">Client Encryption Keys Calculation</div>
<div class="explanation">
	The client now has the information to calculate the encryption
	keys that will be used by each side.  It uses the following
	information in this calculation:
	<ul>
	<li>server random (from Server Hello)
	<li>client random (from Client Hello)
	<li>server public key (from Server Key Exchange)
	<li>client private key (from Client Key Generation)
	</ul>
	The client multiplies the server's public key with the
	client's public key using the curve25519() algorithm.  The
	32-byte result is called the PreMasterSecret, and is found
	to be:
<pre class="ind2"><tt>df 4a 29 1b aa 1e b7 cf a6 93 4b 29 b4 74 ba ad
26 97 e2 9f 1f 92 0d cc 77 c8 a0 a0 88 44 76 24</tt></pre>

	I've provided <a href="files/curve25519-mult.c">a tool</a> to perform this calculation:
<codesample>
<pre><code>$ gcc -o curve25519-mult curve25519-mult.c
$ ./curve25519-multi client-ephemeral-private.key \
                     server-ephemeral-public.key | hexdump

0000000 df 4a 29 1b aa 1e b7 cf a6 93 4b 29 b4 74 ba ad
0000010 26 97 e2 9f 1f 92 0d cc 77 c8 a0 a0 88 44 76 24
</code></pre>
</codesample>

	The client then calculates 48 bytes of the MasterSecret
	from the PreMasterSecret using the following method:

	<pre class="ind1">seed = "master secret" + client_random + server_random
a0 = seed
a1 = HMAC-SHA256(key=PreMasterSecret, data=a0)
a2 = HMAC-SHA256(key=PreMasterSecret, data=a1)
p1 = HMAC-SHA256(key=PreMasterSecret, data=a1 + seed)
p2 = HMAC-SHA256(key=PreMasterSecret, data=a2 + seed)
MasterSecret = p1[32 bytes] + p2[bytes 0-16]</pre>

	Here we demonstrate on the command line:
<codesample>
<pre><code>### set up our PreMasterSecret as a hex string
$ pmshex=df4a291baa1eb7cfa6934b29b474baad
$ pmshex=${pmshex}2697e29f1f920dcc77c8a0a088447624
### client random from Client Hello
$ echo -en '\x00\x01\x02\x03\x04\x05\x06\x07' >  /tmp/c_rand
$ echo -en '\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f' >> /tmp/c_rand
$ echo -en '\x10\x11\x12\x13\x14\x15\x16\x17' >> /tmp/c_rand
$ echo -en '\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f' >> /tmp/c_rand
### server random from Server Hello
$ echo -en '\x70\x71\x72\x73\x74\x75\x76\x77' >  /tmp/s_rand
$ echo -en '\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f' >> /tmp/s_rand
$ echo -en '\x80\x81\x82\x83\x84\x85\x86\x87' >> /tmp/s_rand
$ echo -en '\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f' >> /tmp/s_rand
### build the seed
$ echo -en 'master secret' > /tmp/seed
$ cat /tmp/c_rand /tmp/s_rand >> /tmp/seed
### a0 is the same as the seed
$ cat /tmp/seed > /tmp/a0
### a(n) is hmac-sha256(key=secret, data=a(n-1))
$ cat /tmp/a0 | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$pmshex -binary > /tmp/a1
$ cat /tmp/a1 | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$pmshex -binary > /tmp/a2
### p(n) is hmac-sha256(key=secret, data=a(n)+seed)
$ cat /tmp/a1 /tmp/seed | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$pmshex -binary > /tmp/p1
$ cat /tmp/a2 /tmp/seed | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$pmshex -binary > /tmp/p2
$ cat /tmp/p1 /tmp/p2 | head -c 48 > /tmp/mastersecret
$ hexdump /tmp/mastersecret

0000000 91 6a bf 9d a5 59 73 e1 36 14 ae 0a 3f 5d 3f 37
0000010 b0 23 ba 12 9a ee 02 cc 91 34 33 81 27 cd 70 49
0000020 78 1c 8e 19 fc 1e b2 a7 38 7a c0 6a e2 37 34 4c
</code></pre>
</codesample>

	This gives us a MasterSecret of:
<pre class="ind1"><tt>91 6a bf 9d a5 59 73 e1 36 14 ae 0a 3f 5d 3f 37
b0 23 ba 12 9a ee 02 cc 91 34 33 81 27 cd 70 49
78 1c 8e 19 fc 1e b2 a7 38 7a c0 6a e2 37 34 4c</tt></pre>

	We then generate the final encryption keys using a key expansion:

<pre class="ind1">
seed = "key expansion" + server_random + client_random
a0 = seed
a1 = HMAC-SHA256(key=MasterSecret, data=a0)
a2 = HMAC-SHA256(key=MasterSecret, data=a1)
a3 = HMAC-SHA256(key=MasterSecret, data=a2)
p1 = HMAC-SHA256(key=MasterSecret, data=a1 + seed)
p2 = HMAC-SHA256(key=MasterSecret, data=a2 + seed)
p3 = HMAC-SHA256(key=MasterSecret, data=a3 + seed)
client_write_key = p1[32 bytes]
server_write_key = p2[32 bytes]
client_write_IV = p3[bytes 0-11]
server_write_IV = p3[bytes 12-23]</pre>

	We can demonstrate this on the command line:
<codesample>
<pre><code>### continued from above command line example
### set up our MasterSecret as a hex string
$ mshex=$(hexdump -e '/1 "%02x"' /tmp/mastersecret)
### build the seed
$ echo -en 'key expansion' > /tmp/seed
$ cat /tmp/s_rand /tmp/c_rand >> /tmp/seed
### a0 is the same as the seed
$ cat /tmp/seed > /tmp/a0
### a(n) is hmac-sha256(key=secret, data=a(n-1))
$ cat /tmp/a0 | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$mshex -binary > /tmp/a1
$ cat /tmp/a1 | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$mshex -binary > /tmp/a2
$ cat /tmp/a2 | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$mshex -binary > /tmp/a3
### p(n) is hmac-sha256(key=secret, data=a(n)+seed)
$ cat /tmp/a1 /tmp/seed | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$mshex -binary > /tmp/p1
$ cat /tmp/a2 /tmp/seed | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$mshex -binary > /tmp/p2
$ cat /tmp/a3 /tmp/seed | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$mshex -binary > /tmp/p3
$ cat /tmp/p1 > /tmp/client_key
$ cat /tmp/p2 > /tmp/server_key
$ cat /tmp/p3 | head -c 12 > /tmp/client_iv
$ cat /tmp/p3 | tail -c 20 | head -c 12 > /tmp/server_iv
$ hexdump /tmp/client_key

0000000 1b 7d 11 7c 7d 5f 69 0b c2 63 ca e8 ef 60 af 0f
0000010 18 78 ac c2 2a d8 bd d8 c6 01 a6 17 12 6f 63 54

$ hexdump /tmp/server_key

0000000 0e b2 09 06 f7 81 fa d2 f6 56 d0 37 b1 73 ef 3e
0000010 11 16 9f 27 23 1a 84 b6 75 2a 18 e7 a9 fc b7 cb

$ hexdump /tmp/client_iv

0000000 cd d8 f9 8d d8 f7 69 eb a0 d2 55 0c

$ hexdump /tmp/server_iv

0000000 92 38 ee bf ef 5c 32 25 1a bb 67 d6
</code></pre>
</codesample>

	From this we get the following key data:
	<ul>
	<li>client write key: <tt>1b 7d 11 7c 7d 5f 69 0b c2 63 ca e8 ef 60 af 0f
		18 78 ac c2 2a d8 bd d8 c6 01 a6 17 12 6f 63 54</tt>
	<li>server write key: <tt>0e b2 09 06 f7 81 fa d2 f6 56 d0 37 b1 73 ef 3e
		0000010 11 16 9f 27 23 1a 84 b6 75 2a 18 e7 a9 fc b7 cb</tt>
	<li>client write IV: <tt>cd d8 f9 8d d8 f7 69 eb a0 d2 55 0c</tt>
	<li>server write IV: <tt>92 38 ee bf ef 5c 32 25 1a bb 67 d6</tt>
	</ul>
</div>
</div>

<div class="record client">
<div class="label">Client Change Cipher Spec</div>
<div class="explanation">
	The client indicates that it has calculated the shared
	encryption keys and that all following messages from the
	client will be encrypted with the client write key.
	<br/><br/>
	In the next version of TLS this message type has been removed because it can be inferred.
	<br/>&nbsp;
</div>
<span class="record-data">
	<span class="string">
		<span class="label">record</span>
		<span class="bytes">
			14 03 03 00 01 01
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<br/><br/>
			In this record header we see the following:
			<ul>
			<li><tt>14</tt> - type is 0x14 (ChangeCipherSpec record)
			<li><tt>03 03</tt> - protocol version is 3.3 (TLS 1.2)
			<li><tt>00 01</tt> - the length of the record payload is 0x01 (1) bytes
			<li><tt>01</tt> - the payload of this message is defined as the byte 0x01
			</ul>
		</div>
	</span>
</span>
</div>

<div class="record client">
<div class="label">Client Handshake Finished</div>
<div class="explanation">
	To verify that the handshake was successful and not tampered
	with, the client calculates verify_data and encrypts
	it with the client_write key.
	<br/><br/>
	The verify_data is built from the master secret and the
	hash of the payload of all handshake records (type=0x16) previous to this one.
	<br/><br/>
	The calculation for verify_data is as follows:
<pre class="ind1">
seed = "client finished" + SHA256(all handshake messages)
a0 = seed
a1 = HMAC-SHA256(key=MasterSecret, data=a0)
p1 = HMAC-SHA256(key=MasterSecret, data=a1 + seed)
verify_data = p1[bytes 0-11]
</pre>
	The SHA256 of all handshake messages before this one
	is <tt>7d5f1060a3f28ffb 0871c0de00b90c0e
	       8a276a747e81b951 fa288434623c5ebf</tt>.
	<br/><br/>
	The calculated verify data is <tt>a0 74 4d d4 9a 21 2f 15 2b 3c 06 0d</tt>.  We can show this on the command line:
<codesample>
<pre><code>### set up our MasterSecret as a hex string
$ mshex=$(hexdump -e '/1 "%02x"' /tmp/mastersecret)
### build the seed
$ echo -en 'client finished' > /tmp/seed
### add SHA256(all_messages) to seed
$ echo -en '\x7d\x5f\x10\x60\xa3\xf2\x8f\xfb' >> /tmp/seed
$ echo -en '\x08\x71\xc0\xde\x00\xb9\x0c\x0e' >> /tmp/seed
$ echo -en '\x8a\x27\x6a\x74\x7e\x81\xb9\x51' >> /tmp/seed
$ echo -en '\xfa\x28\x84\x34\x62\x3c\x5e\xbf' >> /tmp/seed
### a0 is the same as the seed
$ cat /tmp/seed > /tmp/a0
### a(n) is hmac-sha256(key=secret, data=a(n-1))
$ cat /tmp/a0 | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$mshex -binary > /tmp/a1
### p(n) is hmac-sha256(key=secret, data=a(n)+seed)
$ cat /tmp/a1 /tmp/seed | openssl dgst -sha256 \
   -mac HMAC -macopt hexkey:$mshex -binary > /tmp/p1
$ head -c 12 /tmp/p1 > /tmp/verify_data
$ hexdump /tmp/verify_data

0000000 a0 74 4d d4 9a 21 2f 15 2b 3c 06 0d
</code></pre>
</codesample>
</div>

<span class="record-data">
	<span class="string">
		<span class="label">record header</span>
		<span class="bytes">
			16 03 03 00 20
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<br/><br/>
			In this record header we see the following:
			<ul>
			<li><tt>16</tt> - type is 0x16 (handshake record)
			<li><tt>03 03</tt> - protocol version is 3.3 (TLS 1.2)
			<li><tt>00 20</tt> - the length of the record payload is 0x20 (32) bytes
			</ul>
			All data following this header is the payload for this record.
		</div>
	</span>

	<span class="string">
		<span class="label">encrypted data</span>
		<span class="bytes">
			de e7 6c b8 34 68 5e 69 21 30 7a 15 26 a2 8a 35
			d9 5b 9c 3b 3b 26 42 49 65 f2 87 3e 0e 42 49 3d
		</span>
		<div class="explanation">
			This data is encrypted with the client write key and IV.

			It can be decrypted by pressing the "Decrypt data" button.
		</div>
	</span>
</span>
</div>

<div class="record server">
<div class="label">Server Change Cipher Spec</div>
<span class="record-data">
 14 03 03 00 01 01
</span>
</div>

<div class="record server">
<div class="label">Server Handshake Finished</div>
<span class="record-data">
16 03 03 00 20 ec 1e b8 af bf e5 14 80 03 3f bd 40 4a 13 94 93 59 bb d4 59 97 96 ea 0f d8 dd 37 37 c6 25 b8 d3
</span>
</div>

<div class="record client">
<div class="label">Client Application Data</div>
<span class="record-data">
 17 03 03 00 14 38 1c 53 d0 e1 d0 da 47 c8 ef d5 67 b1 8b c2 0d b4 70 96 7e
</span>
</div>

<div class="record server">
<div class="label">Server Application Data</div>
<span class="record-data">
 17 03 03 00 14 47 dd 8b cd b9 03 9a c0 22 bb 41 ce cc 71 f4 c3 b0 c2 2d 4c
</span>
</div>

<div class="record client">
<div class="label">Client Close Notify</div>
<span class="record-data">
 15 03 03 00 12 b2 5e dd 7d f9 e7 b8 16 cc ae f2 b7 4b 6d 89 63 9f 85
</span>
</div>

	<div class="outerblock">
	<p>The code for this project can be found
	<a href="https://github.com/syncsynchalt/illustrated-tls">on GitHub</a>.</p>
	</div>

	<div class="outerblock">
	<p>If you found this page useful or interesting let me know via Twitter
	<a href="https://twitter.com/xargsnotbombs">@XargsNotBombs</a>.</p>
	</div>

</div>

<div id="templates" style="display: none">
	<div id="closeBtnTmpl">
		<span class="close" onclick="ill.unselectAllStrings()">&times;</span>
	</div>
	<div id="showCodeTmpl">
		<button class="show-code" onclick="ill.showCode(this, event)">Show Code</button>
	</div>
</div>
</body>
